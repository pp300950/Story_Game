<!DOCTYPE html>
<html lang="th">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á</title>
    <style>
      body {
        font-family: 'Segoe UI', sans-serif;
        background-color: #121212;
        color: #e0e0e0;
        margin: 0;
        padding: 20px;
        overflow-x: hidden; /* Prevent horizontal scroll */
      }
      .container {
        max-width: 900px;
        margin: auto;
        background-color: #1e1e1e;
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 20px;
      }
      h1 {
        text-align: center;
        color: #00bcd4;
      }
      .scene {
        border: 1px solid #333;
        padding: 15px;
        margin-bottom: 20px;
        border-radius: 5px;
        background-color: #2a2a2a;
        cursor: grab; /* Indicate draggable */
      }
      .scene.dragging {
        opacity: 0.5;
        border: 2px dashed #00bcd4;
      }
      .scene.highlight {
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
        border-color: #00ffff;
      }
      .scene-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        cursor: pointer;
        padding: 10px;
        background-color: #333;
        border-radius: 5px;
        margin: -15px -15px 15px -15px;
      }
      .scene-header h3 {
        margin: 0;
        color: #fff;
      }
      .scene-content {
        display: none;
        padding-top: 10px;
      }
      .scene.active .scene-content {
        display: block;
      }
      .form-group {
        margin-bottom: 15px;
      }
      .form-group label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
      }
      .form-group input,
      .form-group textarea {
        width: 100%;
        padding: 8px;
        box-sizing: border-box;
        border: 1px solid #555;
        background-color: #444;
        color: #e0e0e0;
        border-radius: 4px;
      }
      .choice-list {
        margin-top: 10px;
        padding-left: 0;
      }
      .choice-item {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 5px;
      }
      .choice-item input {
        flex-grow: 1;
      }
      .add-choice-btn,
      .remove-choice-btn,
      .add-scene-btn,
      .remove-scene-btn,
      #export-btn,
      #search-btn,
      #import-btn {
        padding: 8px 12px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
      }
      .add-choice-btn {
        background-color: #4caf50;
        color: white;
      }
      .remove-choice-btn {
        background-color: #f44336;
        color: white;
      }
      .add-scene-btn {
        background-color: #2196f3;
        color: white;
        margin-top: 10px;
      }
      .remove-scene-btn {
        background-color: #f44336;
        color: white;
      }
      #export-btn {
        background-color: #00bcd4;
        color: white;
        width: 100%;
        margin-top: 20px;
      }
      #import-btn {
        background-color: #673ab7;
        color: white;
        width: 100%;
        margin-top: 10px;
      }
      .controls {
        text-align: center;
        margin-top: 20px;
      }
      .search-controls {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
        align-items: center;
      }
      .search-controls input {
        flex-grow: 1;
      }
      #search-btn {
        background-color: #ff9800;
        color: white;
      }

      /* Styles for the flowchart */
      .flowchart-container {
        max-width: 900px;
        margin: 20px auto;
        background-color: #1e1e1e;
        padding: 20px;
        border-radius: 8px;
        border: 1px solid #333;
      }

      .flowchart-container h2 {
        text-align: center;
        color: #4caf50;
        margin-top: 0;
      }

      .mermaid {
        background-color: #2a2a2a;
        padding: 10px;
        border-radius: 5px;
        width: 100%;
        height: 600px;
        display: block;
      }

      /* === Image Picker Sidebar Styles === */
      #image-picker-toggle {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 1001;
        background-color: #00bcd4;
        color: white;
        border: none;
        padding: 10px 15px;
        border-radius: 0 5px 5px 0;
        cursor: pointer;
        font-size: 1.5em;
        transition: transform 0.3s ease;
        z-index: 1002; /* ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏õ‡∏∏‡πà‡∏° toggle ‡∏≠‡∏¢‡∏π‡πà‡∏ö‡∏ô‡∏™‡∏∏‡∏î */
      }
      /* ‡πÄ‡∏û‡∏¥‡πà‡∏° CSS ‡πÉ‡∏´‡∏°‡πà: ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ã‡πà‡∏≠‡∏ô‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡∏´‡∏•‡∏±‡∏Å‡πÄ‡∏°‡∏∑‡πà‡∏≠ sidebar ‡πÄ‡∏õ‡∏¥‡∏î */
      body.sidebar-open .container,
      body.sidebar-open .flowchart-container,
      body.sidebar-open #image-picker-toggle {
        display: none;
      }
      #image-picker-sidebar {
        position: fixed;
        top: 0;
        left: 0;
        width: 300px;
        height: 100vh;
        background-color: #2a2a2a;
        box-shadow: 2px 0 10px rgba(0, 0, 0, 0.5);
        transform: translateX(-100%);
        transition: transform 0.3s ease;
        z-index: 1000;
        padding: 20px;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        width: 100vw; /* ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡πÅ‡∏ñ‡∏ö sidebar ‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠ */
        height: 100vh;
        padding: 50px 20px 20px; /* ‡πÄ‡∏û‡∏¥‡πà‡∏° padding ‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏±‡∏ö‡∏õ‡∏∏‡πà‡∏° close */
        box-sizing: border-box;
      }

      #image-picker-sidebar.active {
        transform: translateX(0);
      }

      #image-picker-close {
        position: absolute;
        top: 10px;
        right: 10px;
        background: transparent;
        color: white;
        border: none;
        font-size: 1.5em;
        cursor: pointer;
      }

      #image-picker-sidebar h3 {
        color: #00bcd4;
        text-align: center;
        margin-top: 0;
        margin-bottom: 20px;
      }

      .image-carousel-container {
        position: relative;
        overflow: hidden;
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        justify-content: center;
      }

      .image-carousel {
        display: flex;
        transition: transform 0.3s ease;
        width: 100%; /* Important for carousel logic */
      }

      .carousel-item {
        min-width: 100%;
        box-sizing: border-box;
        text-align: center;
      }

      .carousel-item img {
        max-width: 100%;
        height: auto;
        border-radius: 8px;
        border: 1px solid #555;
        max-height: 40vh;
        object-fit: contain;
      }

      .carousel-caption {
        margin-top: 10px;
        word-wrap: break-word;
        font-size: 0.9em;
      }

      .copy-path-btn {
        background-color: #4caf50;
        color: white;
        border: none;
        padding: 5px 10px;
        border-radius: 4px;
        margin-top: 5px;
        cursor: pointer;
      }

      .carousel-controls {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 20px;
        margin-top: 20px;
      }

      .carousel-btn {
        background-color: #555;
        color: white;
        border: none;
        padding: 10px 15px;
        border-radius: 50%;
        cursor: pointer;
        font-size: 1.2em;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .carousel-btn:hover {
        background-color: #00bcd4;
      }
    </style>
  </head>
  <body>
    <button id="image-picker-toggle">üñºÔ∏è</button>
    <div id="image-picker-sidebar">
      <button id="image-picker-close">‚úï</button>
      <h3>‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á</h3>
      <div class="image-carousel-container">
        <div class="image-carousel" id="image-carousel"></div>
      </div>
      <div class="carousel-controls">
        <button id="prev-btn" class="carousel-btn">‚Üê</button>
        <button id="next-btn" class="carousel-btn">‚Üí</button>
      </div>
    </div>
    <div class="container">
      <h1>‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á</h1>

      <div class="search-controls">
        <input
          type="text"
          id="scene-search-input"
          placeholder="‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏î‡πâ‡∏ß‡∏¢ Scene ID ‡∏´‡∏£‡∏∑‡∏≠ Title"
        />
        <button id="search-btn">üîç ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏â‡∏≤‡∏Å</button>
      </div>

      <div id="editor"></div>
      <div class="controls">
        <button id="add-scene-btn" class="add-scene-btn">
          ‚ûï ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏â‡∏≤‡∏Å‡πÉ‡∏´‡∏°‡πà
        </button>
        <button id="export-btn">‚¨áÔ∏è ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå JSON</button>
        <input
          type="file"
          id="import-file-input"
          accept=".json"
          style="display: none"
        />
        <button id="import-btn">‚¨ÜÔ∏è ‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏ü‡∏•‡πå JSON</button>
      </div>
    </div>

    <div class="flowchart-container">
      <h2>‡πÅ‡∏ú‡∏ô‡∏ú‡∏±‡∏á‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á (Story Flowchart)</h2>
      <div class="mermaid" id="flowchart"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js"></script>
    <script>
      // Initialize Mermaid globally once
      mermaid.initialize({
        startOnLoad: false,
        theme: 'dark',
        flowchart: {
          curve: 'basis',
          htmlLabels: true,
        },
        securityLevel: 'loose',
      });

      const defaultDialogueData = [
        {
          id: 'start',
          text: '‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏ï‡πâ‡∏≠‡∏ô‡∏£‡∏±‡∏ö‡∏™‡∏π‡πà‡πÇ‡∏•‡∏Å‡πÅ‡∏´‡πà‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏à‡∏£‡∏à‡∏≤, {name} ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏à‡∏∞‡πÑ‡∏î‡πâ‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ‡∏ñ‡∏∂‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥‡∏û‡∏π‡∏î ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡πÉ‡∏à‡πÉ‡∏ô‡∏†‡∏≤‡∏£‡∏Å‡∏¥‡∏à‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏à‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ä‡∏∞‡∏ï‡∏≤‡∏Ç‡∏≠‡∏á‡∏õ‡∏£‡∏∞‡πÄ‡∏ó‡∏®‡∏ä‡∏≤‡∏ï‡∏¥',
          background: 'Pic/checkhand.jpeg',
          choices: [{ text: '‡∏ï‡πà‡∏≠‡πÑ‡∏õ', next: 'intro1' }],
        },
        {
          id: 'intro1',
          text: '‡∏Ñ‡∏∏‡∏ì‡∏à‡∏∞‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏ö‡∏ó‡πÄ‡∏õ‡πá‡∏ô‡∏ô‡∏±‡∏Å‡πÄ‡∏à‡∏£‡∏à‡∏≤ ‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏≥‡∏û‡∏π‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏°‡∏µ‡∏û‡∏•‡∏±‡∏á‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏∏‡∏Å‡∏™‡∏¥‡πà‡∏á ‡∏Ñ‡∏≥‡∏û‡∏π‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏≠‡∏ô‡∏≤‡∏Ñ‡∏ï!',
          background: 'Pic/present2.jpeg',
          choices: [{ text: '‡∏ï‡πà‡∏≠‡πÑ‡∏õ', next: 'intro2' }],
        },
        {
          id: 'intro2',
          text: '‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡∏™‡∏ñ‡∏≤‡∏ô‡∏ó‡∏π‡∏ï ‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì ‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏Ç‡πâ‡∏≤‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÉ‡∏ô‡∏ß‡∏±‡∏ô‡πÄ‡πÄ‡∏£‡∏Å‡∏Å‡πá‡∏°‡∏µ‡∏†‡∏≤‡∏£‡∏Å‡∏¥‡∏à‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡πÄ‡πÄ‡∏•‡πâ‡∏ß!',
          background: 'Pic/placWork.jpeg',
          choices: [{ text: '‡∏ï‡πà‡∏≠‡πÑ‡∏õ', next: 'intro3' }],
        },
        {
          id: 'intro3',
          title:
            '‡∏Ç‡πà‡∏≤‡∏ß‡∏•‡∏∑‡∏≠‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏±‡∏Å‡∏•‡∏≠‡∏ö‡∏Ç‡∏ô‡∏™‡πà‡∏á‡∏≠‡∏≤‡∏ß‡∏∏‡∏ò‡∏Ç‡πâ‡∏≤‡∏°‡∏û‡∏£‡∏°‡πÅ‡∏î‡∏ô‡∏õ‡∏£‡∏∞‡πÄ‡∏ó‡∏®‡πÄ‡∏£‡∏≤‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏∞‡πÄ‡∏ó‡∏®‡πÄ‡∏ã‡πÄ‡∏ô‡∏µ‡∏¢‡∏£‡πå',
          text: '‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏Ç‡πà‡∏≤‡∏ß‡∏Å‡∏£‡∏≠‡∏á‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏•‡∏±‡∏Å‡∏•‡∏≠‡∏ö‡∏Ç‡∏ô‡∏≠‡∏≤‡∏ß‡∏∏‡∏ò‡∏à‡∏≤‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏ó‡∏®‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡∏ï‡πÄ‡πÄ‡∏î‡∏ô‡∏Ç‡∏≠‡∏á‡πÄ‡∏ã‡πÄ‡∏ô‡∏µ‡∏¢‡∏£‡πå ‡∏Ñ‡∏∏‡∏ì‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏∞‡∏ô‡∏±‡∏Å‡∏Å‡∏≤‡∏£‡∏ó‡∏π‡∏ï‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡πÉ‡∏à‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏£‡∏±‡∏ö‡∏°‡∏∑‡∏≠‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÑ‡∏£',
          background: 'Pic/box.jpeg',
          choices: [{ text: '‡∏ï‡πà‡∏≠‡πÑ‡∏õ', next: 'mission1' }],
        },
      ];

      const editor = document.getElementById('editor');
      const addSceneBtn = document.getElementById('add-scene-btn');
      const exportBtn = document.getElementById('export-btn');
      const sceneSearchInput = document.getElementById('scene-search-input');
      const searchBtn = document.getElementById('search-btn');
      const importFileInput = document.getElementById('import-file-input');
      const importBtn = document.getElementById('import-btn');

      let draggedSceneIndex = null;

      function sanitizeMermaidId(id) {
        if (typeof id !== 'string') {
          return String(id).replace(/[^a-zA-Z0-9_-]/g, '-');
        }
        return id.replace(/[^a-zA-Z0-9_-]/g, '-');
      }

      function saveDataToLocalStorage() {
        localStorage.setItem('dialogueData', JSON.stringify(dialogueData));
      }

      function loadDataFromLocalStorage() {
        const savedData = localStorage.getItem('dialogueData');
        if (savedData) {
          try {
            return JSON.parse(savedData);
          } catch (e) {
            console.error('Error parsing data from localStorage:', e);
            return defaultDialogueData;
          }
        }
        return defaultDialogueData;
      }

      dialogueData = loadDataFromLocalStorage();

      function renderEditor() {
        editor.innerHTML = '';
        dialogueData.forEach((scene, index) => {
          if (Object.keys(scene).length === 0) return;

          const sceneDiv = document.createElement('div');
          sceneDiv.className = 'scene';
          sceneDiv.setAttribute('draggable', 'true');
          sceneDiv.dataset.index = index;

          sceneDiv.addEventListener('dragstart', (e) => {
            draggedSceneIndex = index;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', index);
          });

          sceneDiv.addEventListener('dragover', (e) => {
            e.preventDefault();
            if (
              e.target.closest('.scene') &&
              e.target.closest('.scene') !== e.target.closest('.scene.dragging')
            ) {
              const targetScene = e.target.closest('.scene');
              const bounding = targetScene.getBoundingClientRect();
              const offset = bounding.y + bounding.height / 2;
              if (e.clientY < offset) {
                targetScene.style.borderTop = '2px solid #00ffff';
                targetScene.style.borderBottom = 'none';
              } else {
                targetScene.style.borderBottom = '2px solid #00ffff';
                targetScene.style.borderTop = 'none';
              }
            }
          });

          sceneDiv.addEventListener('dragleave', (e) => {
            if (e.target.closest('.scene')) {
              e.target.closest('.scene').style.borderTop = 'none';
              e.target.closest('.scene').style.borderBottom = 'none';
            }
          });

          sceneDiv.addEventListener('drop', (e) => {
            e.preventDefault();
            const targetScene = e.target.closest('.scene');
            if (targetScene && draggedSceneIndex !== null) {
              const targetIndex = parseInt(targetScene.dataset.index);
              const draggedItem = dialogueData[draggedSceneIndex];
              dialogueData.splice(draggedSceneIndex, 1);
              const bounding = targetScene.getBoundingClientRect();
              const offset = bounding.y + bounding.height / 2;
              let newIndex = targetIndex;
              if (e.clientY >= offset && draggedSceneIndex < targetIndex) {
                newIndex = targetIndex;
              } else if (
                e.clientY < offset &&
                draggedSceneIndex > targetIndex
              ) {
                newIndex = targetIndex;
              } else if (
                e.clientY < offset &&
                draggedSceneIndex < targetIndex
              ) {
                newIndex = targetIndex - 1;
              } else if (
                e.clientY >= offset &&
                draggedSceneIndex > targetIndex
              ) {
                newIndex = targetIndex + 1;
              }
              dialogueData.splice(newIndex, 0, draggedItem);
              saveDataToLocalStorage();
              renderEditor();
              renderFlowchart();
            }
            if (targetScene) {
              targetScene.style.borderTop = 'none';
              targetScene.style.borderBottom = 'none';
            }
          });

          sceneDiv.addEventListener('dragend', (e) => {
            e.target.classList.remove('dragging');
            draggedSceneIndex = null;
            document.querySelectorAll('.scene').forEach((s) => {
              s.style.borderTop = 'none';
              s.style.borderBottom = 'none';
            });
          });

          const header = document.createElement('div');
          header.className = 'scene-header';
          header.innerHTML = `<h3>‡∏â‡∏≤‡∏Å‡∏ó‡∏µ‡πà ${index + 1}: ${
            scene.id || '‡πÑ‡∏°‡πà‡∏°‡∏µ ID'
          }</h3>
                              <button class="remove-scene-btn" onclick="removeScene(${index})">üóëÔ∏è ‡∏•‡∏ö‡∏â‡∏≤‡∏Å</button>`;
          header.onclick = () => {
            sceneDiv.classList.toggle('active');
          };
          sceneDiv.appendChild(header);

          const content = document.createElement('div');
          content.className = 'scene-content';

          content.innerHTML = `
                <div class="form-group">
                    <label>Scene ID:</label>
                    <input type="text" value="${
                      scene.id || ''
                    }" onchange="updateScene(${index}, 'id', this.value); renderFlowchart()">
                </div>
                <div class="form-group">
                    <label>Title (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ):</label>
                    <input type="text" value="${
                      scene.title || ''
                    }" onchange="updateScene(${index}, 'title', this.value); renderFlowchart()">
                </div>
                <div class="form-group">
                    <label>Text:</label>
                    <textarea onchange="updateScene(${index}, 'text', this.value)">${
            scene.text || ''
          }</textarea>
                </div>
                <div class="form-group">
                    <label>Background Image Path:</label>
                    <input type="text" value="${
                      scene.background || ''
                    }" onchange="updateScene(${index}, 'background', this.value)">
                </div>
                <h4>‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å (Choices):</h4>
                <div class="choice-list" id="choices-${index}"></div>
                <button class="add-choice-btn" onclick="addChoice(${index})">‚ûï ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å</button>
            `;
          sceneDiv.appendChild(content);
          editor.appendChild(sceneDiv);

          const choicesList = document.getElementById(`choices-${index}`);
          (scene.choices || []).forEach((choice, choiceIndex) => {
            choicesList.appendChild(
              createChoiceElement(index, choiceIndex, choice)
            );
          });
        });
      }

      function createChoiceElement(sceneIndex, choiceIndex, choice) {
        const choiceItem = document.createElement('div');
        choiceItem.className = 'choice-item';
        choiceItem.innerHTML = `
            <input type="text" placeholder="‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏∑‡∏≠‡∏Å" value="${
              choice.text || ''
            }" onchange="updateChoice(${sceneIndex}, ${choiceIndex}, 'text', this.value)">
            <input type="text" placeholder="Scene ID ‡∏ñ‡∏±‡∏î‡πÑ‡∏õ" value="${
              choice.next || ''
            }" onchange="updateChoice(${sceneIndex}, ${choiceIndex}, 'next', this.value); renderFlowchart()">
            <button class="remove-choice-btn" onclick="removeChoice(${sceneIndex}, ${choiceIndex})">üóëÔ∏è</button>
        `;
        return choiceItem;
      }

      function updateScene(index, key, value) {
        if (key === 'title' && !value) {
          delete dialogueData[index][key];
        } else {
          dialogueData[index][key] = value;
        }
        saveDataToLocalStorage();
      }

      function updateChoice(sceneIndex, choiceIndex, key, value) {
        if (!dialogueData[sceneIndex].choices) {
          dialogueData[sceneIndex].choices = [];
        }
        if (!dialogueData[sceneIndex].choices[choiceIndex]) {
          dialogueData[sceneIndex].choices[choiceIndex] = {};
        }
        dialogueData[sceneIndex].choices[choiceIndex][key] = value;
        saveDataToLocalStorage();
        renderFlowchart();
      }

      function addChoice(sceneIndex) {
        if (!dialogueData[sceneIndex].choices) {
          dialogueData[sceneIndex].choices = [];
        }
        dialogueData[sceneIndex].choices.push({ text: '', next: '' });
        saveDataToLocalStorage();
        renderEditor();
        renderFlowchart();
      }

      function removeChoice(sceneIndex, choiceIndex) {
        dialogueData[sceneIndex].choices.splice(choiceIndex, 1);
        saveDataToLocalStorage();
        renderEditor();
        renderFlowchart();
      }

      function addScene() {
        dialogueData.push({
          id: 'new-scene-' + Date.now(),
          title: '',
          text: '',
          background: '',
          choices: [],
        });
        saveDataToLocalStorage();
        renderEditor();
        renderFlowchart();
        const newSceneElement = editor.lastElementChild;
        if (newSceneElement) {
          newSceneElement.classList.add('active');
          newSceneElement.scrollIntoView({
            behavior: 'smooth',
            block: 'center',
          });
        }
      }

      function removeScene(index) {
        const confirmDelete = confirm('‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏â‡∏≤‡∏Å‡∏ô‡∏µ‡πâ‡πÉ‡∏ä‡πà‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?');
        if (confirmDelete) {
          dialogueData.splice(index, 1);
          saveDataToLocalStorage();
          renderEditor();
          renderFlowchart();
        }
      }

      function exportData() {
        const filteredData = dialogueData.filter(
          (scene) => Object.keys(scene).length > 0
        );
        const dataStr = JSON.stringify(filteredData, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'dialogueData.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      function importData() {
        importFileInput.click();
      }

      importFileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) {
          return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const importedData = JSON.parse(e.target.result);
            if (
              Array.isArray(importedData) &&
              importedData.every(
                (item) => typeof item === 'object' && item !== null
              )
            ) {
              const confirmImport = confirm(
                '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô Editor ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏î‡πâ‡∏ß‡∏¢‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå JSON ‡∏ô‡∏µ‡πâ ‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≠‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?'
              );
              if (confirmImport) {
                dialogueData = importedData;
                saveDataToLocalStorage();
                renderEditor();
                renderFlowchart();
                alert('‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏ü‡∏•‡πå JSON ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!');
              }
            } else {
              alert('‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÑ‡∏ü‡∏•‡πå JSON ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á: ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô Array ‡∏Ç‡∏≠‡∏á Object.');
            }
          } catch (error) {
            console.error('Error parsing JSON file:', error);
            alert(
              '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå JSON: ‡πÇ‡∏õ‡∏£‡∏î‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏ü‡∏•‡πå‡∏°‡∏µ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á'
            );
          }
          event.target.value = '';
        };
        reader.readAsText(file);
      });

      async function renderFlowchart() {
        let flowchartCode = 'graph TD\n';

        dialogueData.forEach((scene) => {
          if (Object.keys(scene).length === 0) return;

          if (scene.id) {
            const mermaidNodeId = sanitizeMermaidId(scene.id);
            let label = scene.id;
            if (scene.title) {
              label = `${scene.title} <br/> (${scene.id})`;
            }
            flowchartCode += `${mermaidNodeId}["${label}"]\n`;

            if (scene.choices && scene.choices.length > 0) {
              scene.choices.forEach((choice, index) => {
                if (choice.next) {
                  const mermaidNextNodeId = sanitizeMermaidId(choice.next);
                  let choiceText = choice.text || `Choice ${index + 1}`;
                  choiceText = choiceText
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, "'")
                    .replace(/`/g, '&#96;');

                  flowchartCode += `${mermaidNodeId} --> |"${choiceText}"| ${mermaidNextNodeId}\n`;
                }
              });
            } else {
              const currentIndex = dialogueData.findIndex(
                (s) => s.id === scene.id
              );
              if (
                currentIndex !== -1 &&
                currentIndex < dialogueData.length - 1
              ) {
                const nextScene = dialogueData[currentIndex + 1];
                if (nextScene && nextScene.id) {
                  const mermaidNextNodeId = sanitizeMermaidId(nextScene.id);
                  flowchartCode += `${mermaidNodeId} --> ${mermaidNextNodeId}\n`;
                }
              }
            }
          }
        });

        console.log('Generated Mermaid Code:\n', flowchartCode);

        const flowchartDiv = document.getElementById('flowchart');
        try {
          const { svg } = await mermaid.render(
            'flowchart-diagram',
            flowchartCode
          );
          flowchartDiv.innerHTML = svg;
        } catch (error) {
          console.error('Mermaid render error:', error);
          flowchartDiv.innerHTML =
            '<p style="color: red;">‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏ú‡∏ô‡∏ú‡∏±‡∏á: ‡πÇ‡∏õ‡∏£‡∏î‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Scene ID ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡πÇ‡∏¢‡∏á</p>';
        }
      }

      function searchScene() {
        const searchTerm = sceneSearchInput.value.toLowerCase().trim();
        if (!searchTerm) {
          alert('‡πÇ‡∏õ‡∏£‡∏î‡∏õ‡πâ‡∏≠‡∏ô‡∏Ñ‡∏≥‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤');
          return;
        }

        document.querySelectorAll('.scene.highlight').forEach((s) => {
          s.classList.remove('highlight');
        });

        const foundSceneIndex = dialogueData.findIndex((scene) => {
          const idMatch =
            scene.id && scene.id.toLowerCase().includes(searchTerm);
          const titleMatch =
            scene.title && scene.title.toLowerCase().includes(searchTerm);
          return idMatch || titleMatch;
        });

        if (foundSceneIndex !== -1) {
          const sceneElement = editor.children[foundSceneIndex];
          if (sceneElement) {
            sceneElement.classList.add('active');
            sceneElement.classList.add('highlight');
            sceneElement.scrollIntoView({
              behavior: 'smooth',
              block: 'center',
            });
            setTimeout(() => {
              sceneElement.classList.remove('highlight');
            }, 3000);
          }
        } else {
          alert('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏â‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏Ñ‡∏≥‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤');
        }
      }

      addSceneBtn.addEventListener('click', addScene);
      exportBtn.addEventListener('click', exportData);
      importBtn.addEventListener('click', importData);
      searchBtn.addEventListener('click', searchScene);

      // === New JavaScript for Image Picker ===
      const imagePickerToggle = document.getElementById('image-picker-toggle');
      const imagePickerSidebar = document.getElementById(
        'image-picker-sidebar'
      );
      const imagePickerClose = document.getElementById('image-picker-close');
      const imageCarousel = document.getElementById('image-carousel');
      const prevBtn = document.getElementById('prev-btn');
      const nextBtn = document.getElementById('next-btn');

      let currentImageIndex = 0;
      let images = [];

      const body = document.body;

      function toggleImagePicker() {
        imagePickerSidebar.classList.toggle('active');
        body.classList.toggle('sidebar-open'); // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î‡∏ô‡∏µ‡πâ
      }

      // Event listeners for the toggle and close buttons
      imagePickerToggle.addEventListener('click', toggleImagePicker);
      imagePickerClose.addEventListener('click', toggleImagePicker);

      // Function to fetch images from the 'Pic' folder (simulated)
      // NOTE: In a real-world scenario, you would use a server-side script
      // or a build process to generate this list. For this static HTML example,
      // we'll use a predefined list.
      function getImagesFromFolder() {
        // This is a simulated list. In a real application, you'd get this from a backend.
        // Make sure to add all your image names to this array.
        return [
          'Pic/20thb.jpeg',
          'Pic/argue.jpeg',
          'Pic/ask.jpeg',
          'Pic/bar.jpeg',
          'Pic/box.jpeg',
          'Pic/boyfriend.jpeg',
          'Pic/built.jpeg',
          'Pic/cafe3.jpeg',
          'Pic/cafestuck.jpeg',
          'Pic/checkhand.jpeg',
          'Pic/checkhand2.jpeg',
          'Pic/checkhand3.jpeg',
          'Pic/coffe.jpeg',
          'Pic/cute_person.jpeg',
          'Pic/deat.jpeg',
          'Pic/dismiss.jpeg',
          'Pic/drawe.jpeg',
          'Pic/exit.jpeg',
          'Pic/findDetailJermi.jpeg',
          'Pic/ghoat.jpeg',
          'Pic/grillPork.jpeg',
          'Pic/hand.jpeg',
          'Pic/leg.jpeg',
          'Pic/mask.jpeg',
          'Pic/me.jpg',
          'Pic/openthedoor.jpeg',
          'Pic/openthedor2.jpeg',
          'Pic/person.jpeg',
          'Pic/phone.jpeg',
          'Pic/placWork.jpeg',
          'Pic/plan.jpeg',
          'Pic/playgame.jpeg',
          'Pic/polic.jpeg',
          'Pic/present.jpeg',
          'Pic/present2.jpeg',
          'Pic/rigis.jpeg',
          'Pic/sleep.jpeg',
          'Pic/talk.jpeg',
          'Pic/teddi.jpeg',
          'Pic/test.jpeg',
          'Pic/think.jpeg',
          'Pic/think2.jpeg',
          'Pic/war.jpeg',
        ];
      }

      function renderImages() {
        images = getImagesFromFolder();
        imageCarousel.innerHTML = '';
        images.forEach((imagePath) => {
          const item = document.createElement('div');
          item.className = 'carousel-item';
          const imageName = imagePath.split('/').pop();
          item.innerHTML = `
            <img src="${imagePath}" alt="${imageName}">
            <div class="carousel-caption">
              <span>${imagePath}</span>
              <button class="copy-path-btn" onclick="copyToClipboard('${imagePath}')">‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å</button>
            </div>
          `;
          imageCarousel.appendChild(item);
        });
        updateCarousel();
      }

      function updateCarousel() {
        const itemWidth =
          imageCarousel.querySelector('.carousel-item').offsetWidth;
        imageCarousel.style.transform = `translateX(${
          -currentImageIndex * itemWidth
        }px)`;
      }

      function nextImage() {
        currentImageIndex = (currentImageIndex + 1) % images.length;
        updateCarousel();
      }

      function prevImage() {
        currentImageIndex =
          (currentImageIndex - 1 + images.length) % images.length;
        updateCarousel();
      }

      function copyToClipboard(text) {
        navigator.clipboard
          .writeText(text)
          .then(() => {
            alert('‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏û‡∏≤‡∏ò‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß: ' + text);
          })
          .catch((err) => {
            console.error('Failed to copy: ', err);
            alert('‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ: ' + text);
          });
      }

      prevBtn.addEventListener('click', prevImage);
      nextBtn.addEventListener('click', nextImage);

      // Add swipe functionality for mobile and desktop
      let touchStartX = 0;
      imageCarousel.addEventListener('touchstart', (e) => {
        touchStartX = e.touches[0].clientX;
      });

      imageCarousel.addEventListener('touchend', (e) => {
        const touchEndX = e.changedTouches[0].clientX;
        if (touchStartX - touchEndX > 50) {
          // Swipe left
          nextImage();
        } else if (touchEndX - touchStartX > 50) {
          // Swipe right
          prevImage();
        }
      });

      // Initial render calls
      renderEditor();
      renderFlowchart();
      renderImages();
    </script>
  </body>
</html>
